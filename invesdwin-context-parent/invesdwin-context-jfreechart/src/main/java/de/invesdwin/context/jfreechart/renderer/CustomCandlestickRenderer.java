package de.invesdwin.context.jfreechart.renderer;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Stroke;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

import javax.annotation.concurrent.NotThreadSafe;

import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.labels.HighLowItemLabelGenerator;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.CrosshairState;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.AbstractXYItemRenderer;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYItemRendererState;
import org.jfree.chart.ui.RectangleEdge;
import org.jfree.chart.util.PaintUtils;
import org.jfree.chart.util.PublicCloneable;
import org.jfree.chart.util.SerialUtils;
import org.jfree.data.Range;
import org.jfree.data.xy.OHLCDataset;
import org.jfree.data.xy.XYDataset;

import de.invesdwin.util.lang.Colors;

/**
 * A renderer that draws candlesticks on an {@link XYPlot} (requires a {@link OHLCDataset}). The example shown here is
 * generated by the <code>CandlestickChartDemo1.java</code> program included in the JFreeChart demo collection: <br>
 * <br>
 * <img src="../../../../../images/CandlestickRendererSample.png" alt="CandlestickRendererSample.png">
 * <P>
 * This renderer does not include code to calculate the crosshair point for the plot.
 */
//CHECKSTYLE:OFF
@NotThreadSafe
public class CustomCandlestickRenderer extends AbstractXYItemRenderer
        implements XYItemRenderer, Cloneable, PublicCloneable, Serializable {

    private static final Color DEFAULT_DOWN_PAINT = Colors.fromHex("#EF5350");

    private static final Color DEFAULT_UP_PAINT = Colors.fromHex("#26A69A");

    /** For serialization. */
    private static final long serialVersionUID = 50390395841817121L;

    /**
     * The number (generally between 0.0 and 1.0) by which the available space automatically calculated for the candles
     * will be multiplied to determine the actual width to use.
     */
    private double autoWidthFactor = 4.5 / 7;

    /** The minimum gap between one candle and the next */
    private double autoWidthGap = 0.0;

    /** The candle width. */
    private double candleWidth;

    /** The maximum candlewidth in milliseconds. */
    private double maxCandleWidthInMilliseconds = 1000.0 * 60.0 * 60.0 * 20.0;

    /** Temporary storage for the maximum candle width. */
    private double maxCandleWidth;

    /**
     * The paint used to fill the candle when the price moved up from open to close.
     */
    private transient Paint upPaint;

    /**
     * The paint used to fill the candle when the price moved down from open to close.
     */
    private transient Paint downPaint;

    /** A flag controlling whether or not volume bars are drawn on the chart. */
    private boolean drawVolume;

    /** Temporary storage for the maximum volume. */
    private transient double maxVolume;

    /**
     * A flag that controls whether or not the renderer's outline paint is used to draw the outline of the candlestick.
     * The default value is <code>false</code> to avoid a change of behaviour for existing code.
     *
     * @since 1.0.5
     */
    private boolean useOutlinePaint;

    private final OHLCDataset dataset;

    /**
     * Creates a new renderer for candlestick charts.
     */
    public CustomCandlestickRenderer(final OHLCDataset dataset) {
        this(dataset, -1.0);
    }

    /**
     * Creates a new renderer for candlestick charts.
     * <P>
     * Use -1 for the candle width if you prefer the width to be calculated automatically.
     *
     * @param candleWidth
     *            The candle width.
     */
    public CustomCandlestickRenderer(final OHLCDataset dataset, final double candleWidth) {
        this(dataset, candleWidth, true, new HighLowItemLabelGenerator());
    }

    /**
     * Creates a new renderer for candlestick charts.
     * <P>
     * Use -1 for the candle width if you prefer the width to be calculated automatically.
     *
     * @param candleWidth
     *            the candle width.
     * @param drawVolume
     *            a flag indicating whether or not volume bars should be drawn.
     * @param toolTipGenerator
     *            the tool tip generator. <code>null</code> is none.
     */
    public CustomCandlestickRenderer(final OHLCDataset dataset, final double candleWidth, final boolean drawVolume,
            final XYToolTipGenerator toolTipGenerator) {
        super();
        setDefaultToolTipGenerator(toolTipGenerator);
        this.candleWidth = candleWidth;
        this.drawVolume = drawVolume;
        this.upPaint = DEFAULT_UP_PAINT;
        this.downPaint = DEFAULT_DOWN_PAINT;
        this.useOutlinePaint = false; // false preserves the old behaviour
                                      // prior to introducing this flag
        setSeriesPaint(0, upPaint);
        this.dataset = dataset;
    }

    public OHLCDataset getDataset() {
        return dataset;
    }

    /**
     * Returns the width of each candle.
     *
     * @return The candle width.
     *
     * @see #setCandleWidth(double)
     */
    public double getCandleWidth() {
        return this.candleWidth;
    }

    /**
     * Sets the candle width and sends a {@link RendererChangeEvent} to all registered listeners.
     * <P>
     * If you set the width to a negative value, the renderer will calculate the candle width automatically based on the
     * space available on the chart.
     *
     * @param width
     *            The width.
     * @see #setAutoWidthMethod(int)
     * @see #setAutoWidthGap(double)
     * @see #setAutoWidthFactor(double)
     * @see #setMaxCandleWidthInMilliseconds(double)
     */
    public void setCandleWidth(final double width) {
        if (width != this.candleWidth) {
            this.candleWidth = width;
            fireChangeEvent();
        }
    }

    /**
     * Returns the maximum width (in milliseconds) of each candle.
     *
     * @return The maximum candle width in milliseconds.
     *
     * @see #setMaxCandleWidthInMilliseconds(double)
     */
    public double getMaxCandleWidthInMilliseconds() {
        return this.maxCandleWidthInMilliseconds;
    }

    /**
     * Sets the maximum candle width (in milliseconds) and sends a {@link RendererChangeEvent} to all registered
     * listeners.
     *
     * @param millis
     *            The maximum width.
     *
     * @see #getMaxCandleWidthInMilliseconds()
     * @see #setCandleWidth(double)
     * @see #setAutoWidthMethod(int)
     * @see #setAutoWidthGap(double)
     * @see #setAutoWidthFactor(double)
     */
    public void setMaxCandleWidthInMilliseconds(final double millis) {
        this.maxCandleWidthInMilliseconds = millis;
        fireChangeEvent();
    }

    /**
     * Returns the factor by which the available space automatically calculated for the candles will be multiplied to
     * determine the actual width to use.
     *
     * @return The width factor (generally between 0.0 and 1.0).
     *
     * @see #setAutoWidthFactor(double)
     */
    public double getAutoWidthFactor() {
        return this.autoWidthFactor;
    }

    /**
     * Sets the factor by which the available space automatically calculated for the candles will be multiplied to
     * determine the actual width to use.
     *
     * @param autoWidthFactor
     *            The width factor (generally between 0.0 and 1.0).
     *
     * @see #getAutoWidthFactor()
     * @see #setCandleWidth(double)
     * @see #setAutoWidthMethod(int)
     * @see #setAutoWidthGap(double)
     * @see #setMaxCandleWidthInMilliseconds(double)
     */
    public void setAutoWidthFactor(final double autoWidthFactor) {
        if (this.autoWidthFactor != autoWidthFactor) {
            this.autoWidthFactor = autoWidthFactor;
            fireChangeEvent();
        }
    }

    /**
     * Returns the amount of space to leave on the left and right of each candle when automatically calculating widths.
     *
     * @return The gap.
     *
     * @see #setAutoWidthGap(double)
     */
    public double getAutoWidthGap() {
        return this.autoWidthGap;
    }

    /**
     * Sets the amount of space to leave on the left and right of each candle when automatically calculating widths and
     * sends a {@link RendererChangeEvent} to all registered listeners.
     *
     * @param autoWidthGap
     *            The gap.
     *
     * @see #getAutoWidthGap()
     * @see #setCandleWidth(double)
     * @see #setAutoWidthMethod(int)
     * @see #setAutoWidthFactor(double)
     * @see #setMaxCandleWidthInMilliseconds(double)
     */
    public void setAutoWidthGap(final double autoWidthGap) {
        if (this.autoWidthGap != autoWidthGap) {
            this.autoWidthGap = autoWidthGap;
            fireChangeEvent();
        }
    }

    /**
     * Returns the paint used to fill candles when the price moves up from open to close.
     *
     * @return The paint (possibly <code>null</code>).
     *
     * @see #setUpPaint(Paint)
     */
    public Paint getUpPaint() {
        return this.upPaint;
    }

    /**
     * Sets the paint used to fill candles when the price moves up from open to close and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param paint
     *            the paint (<code>null</code> permitted).
     *
     * @see #getUpPaint()
     */
    public void setUpPaint(final Paint paint) {
        this.upPaint = paint;
        fireChangeEvent();
    }

    /**
     * Returns the paint used to fill candles when the price moves down from open to close.
     *
     * @return The paint (possibly <code>null</code>).
     *
     * @see #setDownPaint(Paint)
     */
    public Paint getDownPaint() {
        return this.downPaint;
    }

    /**
     * Sets the paint used to fill candles when the price moves down from open to close and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param paint
     *            The paint (<code>null</code> permitted).
     */
    public void setDownPaint(final Paint paint) {
        this.downPaint = paint;
        fireChangeEvent();
    }

    /**
     * Returns a flag indicating whether or not volume bars are drawn on the chart.
     *
     * @return A boolean.
     *
     * @since 1.0.5
     *
     * @see #setDrawVolume(boolean)
     */
    public boolean getDrawVolume() {
        return this.drawVolume;
    }

    /**
     * Sets a flag that controls whether or not volume bars are drawn in the background and sends a
     * {@link RendererChangeEvent} to all registered listeners.
     *
     * @param flag
     *            the flag.
     *
     * @see #getDrawVolume()
     */
    public void setDrawVolume(final boolean flag) {
        if (this.drawVolume != flag) {
            this.drawVolume = flag;
            fireChangeEvent();
        }
    }

    /**
     * Returns the flag that controls whether or not the renderer's outline paint is used to draw the candlestick
     * outline. The default value is <code>false</code>.
     *
     * @return A boolean.
     *
     * @since 1.0.5
     *
     * @see #setUseOutlinePaint(boolean)
     */
    public boolean getUseOutlinePaint() {
        return this.useOutlinePaint;
    }

    /**
     * Sets the flag that controls whether or not the renderer's outline paint is used to draw the candlestick outline,
     * and sends a {@link RendererChangeEvent} to all registered listeners.
     *
     * @param use
     *            the new flag value.
     *
     * @since 1.0.5
     *
     * @see #getUseOutlinePaint()
     */
    public void setUseOutlinePaint(final boolean use) {
        if (this.useOutlinePaint != use) {
            this.useOutlinePaint = use;
            fireChangeEvent();
        }
    }

    /**
     * Returns the range of values the renderer requires to display all the items from the specified dataset.
     *
     * @param dataset
     *            the dataset (<code>null</code> permitted).
     *
     * @return The range (<code>null</code> if the dataset is <code>null</code> or empty).
     */
    @Override
    public Range findRangeBounds(final XYDataset dataset) {
        return findRangeBounds(dataset, true);
    }

    /**
     * Initialises the renderer then returns the number of 'passes' through the data that the renderer will require
     * (usually just one). This method will be called before the first item is rendered, giving the renderer an
     * opportunity to initialise any state information it wants to maintain. The renderer can do nothing if it chooses.
     *
     * @param g2
     *            the graphics device.
     * @param dataArea
     *            the area inside the axes.
     * @param plot
     *            the plot.
     * @param dataset
     *            the data.
     * @param info
     *            an optional info collection object to return data back to the caller.
     *
     * @return The number of passes the renderer requires.
     */
    @Override
    public XYItemRendererState initialise(final Graphics2D g2, final Rectangle2D dataArea, final XYPlot plot,
            final XYDataset dataset, final PlotRenderingInfo info) {

        // calculate the maximum allowed candle width from the axis...
        final ValueAxis axis = plot.getDomainAxis();
        final double x1 = axis.getLowerBound();
        final double x2 = x1 + this.maxCandleWidthInMilliseconds;
        final RectangleEdge edge = plot.getDomainAxisEdge();
        final double xx1 = axis.valueToJava2D(x1, dataArea, edge);
        final double xx2 = axis.valueToJava2D(x2, dataArea, edge);
        this.maxCandleWidth = Math.abs(xx2 - xx1);
        // Absolute value, since the relative x
        // positions are reversed for horizontal orientation

        // calculate the highest volume in the dataset...
        if (this.drawVolume) {
            final OHLCDataset highLowDataset = (OHLCDataset) dataset;
            this.maxVolume = 0.0;
            for (int series = 0; series < highLowDataset.getSeriesCount(); series++) {
                for (int item = 0; item < highLowDataset.getItemCount(series); item++) {
                    final double volume = highLowDataset.getVolumeValue(series, item);
                    if (volume > this.maxVolume) {
                        this.maxVolume = volume;
                    }

                }
            }
        }

        return new XYItemRendererState(info);
    }

    /**
     * Draws the visual representation of a single data item.
     *
     * @param g2
     *            the graphics device.
     * @param state
     *            the renderer state.
     * @param dataArea
     *            the area within which the plot is being drawn.
     * @param info
     *            collects info about the drawing.
     * @param plot
     *            the plot (can be used to obtain standard color information etc).
     * @param domainAxis
     *            the domain axis.
     * @param rangeAxis
     *            the range axis.
     * @param dataset
     *            the dataset.
     * @param series
     *            the series index (zero-based).
     * @param item
     *            the item index (zero-based).
     * @param crosshairState
     *            crosshair information for the plot (<code>null</code> permitted).
     * @param pass
     *            the pass index.
     */
    @Override
    public void drawItem(final Graphics2D g2, final XYItemRendererState state, final Rectangle2D dataArea,
            final PlotRenderingInfo info, final XYPlot plot, final ValueAxis domainAxis, final ValueAxis rangeAxis,
            final XYDataset dataset, final int series, final int item, final CrosshairState crosshairState,
            final int pass) {

        boolean horiz;
        final PlotOrientation orientation = plot.getOrientation();
        if (orientation == PlotOrientation.HORIZONTAL) {
            horiz = true;
        } else if (orientation == PlotOrientation.VERTICAL) {
            horiz = false;
        } else {
            return;
        }

        // setup for collecting optional entity info...
        EntityCollection entities = null;
        if (info != null) {
            entities = info.getOwner().getEntityCollection();
        }

        final OHLCDataset highLowData = (OHLCDataset) dataset;

        final double x = highLowData.getXValue(series, item);
        final double yHigh = highLowData.getHighValue(series, item);
        final double yLow = highLowData.getLowValue(series, item);
        final double yOpen = highLowData.getOpenValue(series, item);
        final double yClose = highLowData.getCloseValue(series, item);

        final RectangleEdge domainEdge = plot.getDomainAxisEdge();
        final double xx = domainAxis.valueToJava2D(x, dataArea, domainEdge);

        final RectangleEdge edge = plot.getRangeAxisEdge();
        final double yyHigh = rangeAxis.valueToJava2D(yHigh, dataArea, edge);
        final double yyLow = rangeAxis.valueToJava2D(yLow, dataArea, edge);
        final double yyOpen = rangeAxis.valueToJava2D(yOpen, dataArea, edge);
        final double yyClose = rangeAxis.valueToJava2D(yClose, dataArea, edge);

        double volumeWidth;
        double stickWidth;
        if (this.candleWidth > 0) {
            // These are deliberately not bounded to minimums/maxCandleWidth to
            //  retain old behaviour.
            volumeWidth = this.candleWidth;
            stickWidth = this.candleWidth;
        } else {
            double xxWidth = 0;
            final int itemCount = state.getLastItemIndex() - state.getFirstItemIndex();
            if (horiz) {
                xxWidth = dataArea.getHeight() / itemCount;
            } else {
                xxWidth = dataArea.getWidth() / itemCount;
            }
            xxWidth -= 2 * this.autoWidthGap;
            xxWidth *= this.autoWidthFactor;
            xxWidth = Math.min(xxWidth, this.maxCandleWidth);
            volumeWidth = Math.max(Math.min(0.0001, this.maxCandleWidth), xxWidth);
            stickWidth = Math.max(Math.min(0.0003, this.maxCandleWidth), xxWidth);
        }

        final Paint p = getItemPaint(series, item);
        Paint outlinePaint = null;
        if (this.useOutlinePaint) {
            outlinePaint = getItemOutlinePaint(series, item);
        }
        final Stroke s = getItemStroke(series, item);

        g2.setStroke(s);

        if (this.drawVolume) {
            final int volume = (int) highLowData.getVolumeValue(series, item);
            final double volumeHeight = volume / this.maxVolume;

            double min, max;
            if (horiz) {
                min = dataArea.getMinX();
                max = dataArea.getMaxX();
            } else {
                min = dataArea.getMinY();
                max = dataArea.getMaxY();
            }

            final double zzVolume = volumeHeight * (max - min);

            g2.setPaint(p);
            final Composite originalComposite = g2.getComposite();
            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2f));

            if (horiz) {
                g2.fill(new Rectangle2D.Double(min, xx - volumeWidth / 2, zzVolume, volumeWidth));
            } else {
                g2.fill(new Rectangle2D.Double(xx - volumeWidth / 2, max - zzVolume, volumeWidth, zzVolume));
            }

            g2.setComposite(originalComposite);
        }

        if (this.useOutlinePaint) {
            g2.setPaint(outlinePaint);
        } else {
            g2.setPaint(p);
        }

        final double yyMaxOpenClose = Math.max(yyOpen, yyClose);
        final double yyMinOpenClose = Math.min(yyOpen, yyClose);
        final double maxOpenClose = Math.max(yOpen, yClose);
        final double minOpenClose = Math.min(yOpen, yClose);

        // draw the upper shadow
        if (yHigh > maxOpenClose) {
            if (horiz) {
                g2.draw(new Line2D.Double(yyHigh, xx, yyMaxOpenClose, xx));
            } else {
                g2.draw(new Line2D.Double(xx, yyHigh, xx, yyMaxOpenClose));
            }
        }

        // draw the lower shadow
        if (yLow < minOpenClose) {
            if (horiz) {
                g2.draw(new Line2D.Double(yyLow, xx, yyMinOpenClose, xx));
            } else {
                g2.draw(new Line2D.Double(xx, yyLow, xx, yyMinOpenClose));
            }
        }

        // draw the body
        Rectangle2D body;
        Rectangle2D hotspot;
        final double length = Math.abs(yyHigh - yyLow);
        final double base = Math.min(yyHigh, yyLow);
        if (horiz) {
            body = new Rectangle2D.Double(yyMinOpenClose, xx - stickWidth / 2, yyMaxOpenClose - yyMinOpenClose,
                    stickWidth);
            hotspot = new Rectangle2D.Double(base, xx - stickWidth / 2, length, stickWidth);
        } else {
            body = new Rectangle2D.Double(xx - stickWidth / 2, yyMinOpenClose, stickWidth,
                    yyMaxOpenClose - yyMinOpenClose);
            hotspot = new Rectangle2D.Double(xx - stickWidth / 2, base, stickWidth, length);
        }
        if (yClose > yOpen) {
            if (this.upPaint != null) {
                g2.setPaint(this.upPaint);
            } else {
                g2.setPaint(p);
            }
            g2.fill(body);
        } else {
            if (this.downPaint != null) {
                g2.setPaint(this.downPaint);
            } else {
                g2.setPaint(p);
            }
            g2.fill(body);
        }
        if (this.useOutlinePaint) {
            g2.setPaint(outlinePaint);
        } else {
            g2.setPaint(p);
        }
        g2.draw(body);

        // add an entity for the item...
        if (entities != null) {
            addEntity(entities, hotspot, dataset, series, item, 0.0, 0.0);
        }

    }

    @Override
    public Paint getItemPaint(final int row, final int column) {
        //determine up or down candle
        final int series = row, item = column;
        final Number yOpen = dataset.getOpen(series, item);
        final Number yClose = dataset.getClose(series, item);
        final boolean isUpCandle = yClose.doubleValue() > yOpen.doubleValue();

        //return the same color as that used to fill the candle
        if (isUpCandle) {
            return getUpPaint();
        } else {
            return getDownPaint();
        }
    }

    /**
     * Tests this renderer for equality with another object.
     *
     * @param obj
     *            the object (<code>null</code> permitted).
     *
     * @return <code>true</code> or <code>false</code>.
     */
    @Override
    public boolean equals(final Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof CustomCandlestickRenderer)) {
            return false;
        }
        final CustomCandlestickRenderer that = (CustomCandlestickRenderer) obj;
        if (this.candleWidth != that.candleWidth) {
            return false;
        }
        if (!PaintUtils.equal(this.upPaint, that.upPaint)) {
            return false;
        }
        if (!PaintUtils.equal(this.downPaint, that.downPaint)) {
            return false;
        }
        if (this.drawVolume != that.drawVolume) {
            return false;
        }
        if (this.maxCandleWidthInMilliseconds != that.maxCandleWidthInMilliseconds) {
            return false;
        }
        if (this.autoWidthFactor != that.autoWidthFactor) {
            return false;
        }
        if (this.autoWidthGap != that.autoWidthGap) {
            return false;
        }
        if (this.useOutlinePaint != that.useOutlinePaint) {
            return false;
        }
        return super.equals(obj);
    }

    /**
     * Returns a clone of the renderer.
     *
     * @return A clone.
     *
     * @throws CloneNotSupportedException
     *             if the renderer cannot be cloned.
     */
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    /**
     * Provides serialization support.
     *
     * @param stream
     *            the output stream.
     *
     * @throws IOException
     *             if there is an I/O error.
     */
    private void writeObject(final ObjectOutputStream stream) throws IOException {
        stream.defaultWriteObject();
        SerialUtils.writePaint(this.upPaint, stream);
        SerialUtils.writePaint(this.downPaint, stream);
    }

    /**
     * Provides serialization support.
     *
     * @param stream
     *            the input stream.
     *
     * @throws IOException
     *             if there is an I/O error.
     * @throws ClassNotFoundException
     *             if there is a classpath problem.
     */
    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        this.upPaint = SerialUtils.readPaint(stream);
        this.downPaint = SerialUtils.readPaint(stream);
    }

    // --- DEPRECATED CODE ----------------------------------------------------

    /**
     * Returns a flag indicating whether or not volume bars are drawn on the chart.
     *
     * @return <code>true</code> if volume bars are drawn on the chart.
     *
     * @deprecated As of 1.0.5, you should use the {@link #getDrawVolume()} method.
     */
    @Deprecated
    public boolean drawVolume() {
        return this.drawVolume;
    }

}
